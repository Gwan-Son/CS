## 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

![싱글톤](https://github.com/user-attachments/assets/fd95addc-fb63-4329-8271-35fd742a6f1e)


#### 장점

-   하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어듦

#### 단점

-   의존성이 높아짐. TDD(Test Dirven Development)를 할 때 걸림돌이 됨.

## 의존성 주입 - DI(Dependency Injection)

모듈 간의 결합을 조금 더 느슨하게 만들 수 있음.

![의존성 주입](https://github.com/user-attachments/assets/01d2b880-b679-49ae-9d8a-abd6fe42aa55)


  
이를 통해 메인모듈(상위모듈)은 하위모듈에 대한 의존성이 떨어지게 됨. -> 디커플링 된다

#### DI의 장점

-   모듈들을 쉽게 교체할 수 있는 구조가 되어, 테스팅하기 쉽고 마이그레이션하기 수월함.
-   구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어 주기 때문에 애플리케이션 의존성 방향이 일관되고, 애플리케이션을 쉽게 추론할 수 있으며, 모듈 간의 관계들이 조금 더 명확해짐.

#### DI의 단점

-   모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며 약간의 런타임 패널티가 생김.

#### DI 원칙

-   상위모듈은 하위모듈에서 어떠한 것도 가져오지 말아야 함.
-   또한, 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부사항에 의존하지 말아야함.

## 팩토리 패턴

객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴.

#### 장점

-   상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 갖게 됨.
-   객체 생성 로직이 따로 떼어져 있기 때문에 유지보수성 증가.

## 전략 패턴(strategy) = 정책 패턴(policy)

객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 '캡슐화된 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

![전략](https://github.com/user-attachments/assets/eb37aa1e-7d0c-4721-8839-a5e0e12d6141)


## 옵저버 패턴

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴

![옵저버](https://github.com/user-attachments/assets/5c50d76a-8f18-4611-a457-1859046424e3)


## 프록시 객체

어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수호출 등)의 작업을 가로챌 수 있는 객체를 뜻함.

## 프록시 패턴

대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나, 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴

## 프록시 서버

서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킴.

## 이터레이터 패턴

이터레이터(iterator)를 사용하여 컬렉션(collection)의 요소들에 접근하는 디자인 패턴

이를 통해 순회할 수 있는 여러가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회가능.

## 노출 모듈 패턴

즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴

## MVC 패턴

모듈(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴

![MVC](https://github.com/user-attachments/assets/3282c660-fcf2-4bad-946d-15b603dfbf2d)


애플리케이션의 구성요소를 세가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있음.

재사용성과 확장성이 용이함.

애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해짐.

모델 : 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등

뷰 : 사용자 인터페이스 요소를 나타냄

컨트롤러 : 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며, 이벤트 등 메인로직 담당

## MVP 패턴

MVC에서 파생되어 Controller가 Presenter로 교체된 패턴

![MVP](https://github.com/user-attachments/assets/2e18e8ba-b064-4023-a247-260956a1572f)


## MVVM 패턴

MVC에서 Controller가 ViewModel로 바뀐 패턴

![MVVM](https://github.com/user-attachments/assets/2778fff3-1c8c-4529-a1c8-4c88424e75e6)


-   뷰모델은 뷰를 더 추상화한 계층이며, MVVM 패턴은 MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징
-   뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정없이 재사용할 수 있고 단위 테스팅하기 쉬움.
